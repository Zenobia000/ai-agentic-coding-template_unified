# 實作引導 (/implement)

## 核心理念
從「可運行」到「可維護」的漸進式實作。完美是優秀的敵人。

## 實作思考框架

### 1. 實作策略
**關鍵決策：**
- 先做什麼能最快驗證核心假設？
- 哪些部分可以用現成的？哪些必須自己寫？
- 如何切分任務讓團隊並行開發？

**策略選擇（自由選用）：**
- Walking Skeleton（先搭骨架）
- Tracer Bullet（端到端穿透）
- Incremental（漸進功能）
- Component-based（組件優先）

### 2. 代碼組織
**考量點：**
- 遵循專案既有慣例還是引入新模式？
- 如何讓新人快速找到代碼？
- 測試代碼放哪裡？

**組織方式（團隊選擇）：**
- By Feature（按功能）
- By Layer（按層次）
- By Type（按類型）
- Hexagonal/Ports-Adapters
- 混合式（大部分專案的現實）

### 3. 介面設計
**設計原則：**
- 介面是契約，要穩定
- 內部實現可以隨時改
- 錯誤處理要明確

**表達方式：**
- OpenAPI Specification
- GraphQL Schema
- Protocol Buffers
- TypeScript Interfaces
- 簡單的函數簽名
- README 中的使用範例

## 實作自由度

### 可彈性決定：
- **測試策略**
  - TDD, BDD, 或傳統測試
  - 單元測試覆蓋率目標
  - 整合測試的範圍

- **開發順序**
  - 核心功能優先
  - 風險最高的優先
  - 依賴最少的優先
  - 用戶價值最高的優先

- **技術細節深度**
  - 詳細的類圖和序列圖
  - 或高層次的模組關係
  - 或專注於關鍵演算法

### 可選擇性包含：
- **效能考量**：預期負載、瓶頸分析、優化策略
- **安全考量**：威脅模型、安全檢查清單
- **部署考量**：環境差異、配置管理、監控
- **資料遷移**：如果影響現有資料
- **向後相容**：如果有既有用戶

## 實用導向

### 代碼範例指引：
- 範例代碼是為了溝通意圖，不是複製貼上
- 展示關鍵模式即可，不需要完整實作
- 偽代碼有時比真代碼更清楚

### 文檔產出建議：
- **給開發者**：能開始寫代碼的足夠資訊
- **給測試者**：知道要測什麼、怎麼測
- **給維運者**：了解部署和監控需求
- **給未來的自己**：為什麼這樣設計

## 最小必要元素

### 必須明確（形式自由）：
1. **模組劃分**：系統怎麼切、誰負責什麼
2. **介面定義**：模組間如何通訊
3. **核心流程**：主要場景如何運作

### 輸出建議：
- 位置：`memory-bank/implementation/`
- 格式：開發者友好的格式
- 更新：隨實作演進更新

## 實作智慧（可選思考）

- 先讓它工作，再讓它優雅，最後讓它快
- 寫代碼時想著讀代碼的人
- 每個函數只做一件事
- 提早整合，經常整合
- 有疑問時，選擇簡單的方案

---

**記住：最好的實作指南是能讓團隊開始工作的指南。**